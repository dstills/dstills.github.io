"use strict";
(self["webpackChunksynview"] = self["webpackChunksynview"] || []).push([["node_modules_esri_calcite-components_dist_components_date_js-_3dee1"],{

/***/ "./node_modules/@esri/calcite-components/dist/components/date.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/date.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ datePartsFromLocalizedString),
/* harmony export */   b: () => (/* binding */ dateFromLocalizedString),
/* harmony export */   c: () => (/* binding */ dateToISO),
/* harmony export */   d: () => (/* binding */ datePartsFromISO),
/* harmony export */   e: () => (/* binding */ dateFromISO),
/* harmony export */   f: () => (/* binding */ dateFromRange),
/* harmony export */   g: () => (/* binding */ getDaysDiff),
/* harmony export */   h: () => (/* binding */ sameDate),
/* harmony export */   i: () => (/* binding */ inRange),
/* harmony export */   j: () => (/* binding */ getOrder),
/* harmony export */   k: () => (/* binding */ formatCalendarYear),
/* harmony export */   l: () => (/* binding */ parseCalendarYear),
/* harmony export */   n: () => (/* binding */ nextMonth),
/* harmony export */   p: () => (/* binding */ prevMonth),
/* harmony export */   s: () => (/* binding */ setEndOfDay)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/@esri/calcite-components/dist/components/locale.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.7.0
 */


/**
 * Check if date is within a min and max
 *
 * @param date
 * @param min
 * @param max
 */
function inRange(date, min, max) {
  if (!date) {
    return;
  }
  const time = date.getTime();
  const afterMin = !(min instanceof Date) || time >= min.getTime();
  const beforeMax = !(max instanceof Date) || time <= max.getTime();
  return afterMin && beforeMax;
}
/**
 * Ensures date is within range,
 * returns min or max if out of bounds
 *
 * @param date
 * @param min
 * @param max
 */
function dateFromRange(date, min, max) {
  if (!(date instanceof Date)) {
    return null;
  }
  const time = date.getTime();
  const beforeMin = min instanceof Date && time < min.getTime();
  const afterMax = max instanceof Date && time > max.getTime();
  if (beforeMin) {
    return min;
  }
  if (afterMax) {
    return max;
  }
  return date;
}
/**
 * Parse an iso8601 string (YYYY-mm-dd) into a valid date.
 * TODO: handle time when time of day UI is added
 *
 * @param iso8601
 * @param isEndDate
 */
function dateFromISO(iso8601, isEndDate = false) {
  if (iso8601 instanceof Date) {
    return iso8601;
  }
  if (!iso8601 || typeof iso8601 !== "string") {
    return null;
  }
  const d = iso8601.split(/[: T-]/).map(parseFloat);
  const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);
  date.setFullYear(d[0]);
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid ISO 8601 date: "${iso8601}"`);
  }
  if (isEndDate) {
    return setEndOfDay(date);
  }
  return date;
}
/**
 * Parse a localized date string into a valid Date.
 * return false if date is invalid, or out of range
 *
 * @param value
 * @param localeData
 */
function dateFromLocalizedString(value, localeData) {
  if (!localeData) {
    return null;
  }
  const { separator } = localeData;
  const parts = parseDateString(value, localeData);
  const { day, month } = parts;
  const year = parseCalendarYear(parts.year, localeData);
  const date = new Date(year, month, day);
  date.setFullYear(year);
  const validDay = day > 0;
  const validMonth = month > -1;
  const validDate = !isNaN(date.getTime());
  const validLength = value.split(separator).filter((c) => c).length > 2;
  const validYear = year.toString().length > 0;
  if (validDay && validMonth && validDate && validLength && validYear) {
    return date;
  }
  return null;
}
function parseCalendarYear(year, localeData) {
  return processCalendarYear(year, localeData, "read");
}
function formatCalendarYear(year, localeData) {
  return processCalendarYear(year, localeData, "write");
}
function processCalendarYear(year, localeData, mode) {
  if (localeData["default-calendar"] !== "buddhist") {
    return year;
  }
  const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;
  const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === "read" ? -1 : 1);
  return year + yearOffset;
}
/**
 * Retrieve day, month, and year strings from a localized string
 *
 * @param string
 * @param localeData
 */
function datePartsFromLocalizedString(string, localeData) {
  const { separator, unitOrder } = localeData;
  const order = getOrder(unitOrder);
  const values = string.split(separator).map((part) => _locale_js__WEBPACK_IMPORTED_MODULE_0__.n.delocalize(part));
  const day = values[order.indexOf("d")];
  const month = values[order.indexOf("m")];
  const year = values[order.indexOf("y")];
  return { day, month, year };
}
/**
 * Return first portion of ISO string (YYYY-mm-dd)
 *
 * @param date
 */
function dateToISO(date) {
  if (date instanceof Date) {
    return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split("T")[0];
  }
  return "";
}
/**
 * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)
 *
 * @param string
 * @param isoDate
 */
function datePartsFromISO(isoDate) {
  const dateParts = isoDate.split("-");
  return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };
}
/**
 * Check if two dates are the same day, month, year
 *
 * @param d1
 * @param d2
 */
function sameDate(d1, d2) {
  return (d1 instanceof Date &&
    d2 instanceof Date &&
    d1.getDate() === d2.getDate() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getFullYear() === d2.getFullYear());
}
/**
 * Get a date one month in the past
 *
 * @param date
 */
function prevMonth(date) {
  const month = date.getMonth();
  const nextDate = new Date(date);
  nextDate.setMonth(month - 1);
  // date doesn't exist in new month, use last day
  if (month === nextDate.getMonth()) {
    return new Date(date.getFullYear(), month, 0);
  }
  return nextDate;
}
/**
 * Get a date one month in the future
 *
 * @param date
 */
function nextMonth(date) {
  const month = date.getMonth();
  const nextDate = new Date(date);
  nextDate.setMonth(month + 1);
  // date doesn't exist in new month, use last day
  if ((month + 2) % 7 === nextDate.getMonth() % 7) {
    return new Date(date.getFullYear(), month + 2, 0);
  }
  return nextDate;
}
/**
 * Parse numeric units for day, month, and year from a localized string
 * month starts at 0 (can pass to date constructor)
 * can return values as number or string
 *
 * @param string
 * @param localeData
 */
function parseDateString(string, localeData) {
  const { day, month, year } = datePartsFromLocalizedString(string, localeData);
  return {
    day: parseInt(day),
    month: parseInt(month) - 1,
    year: parseInt(year),
  };
}
/**
 * Based on the unitOrder string, find order of month, day, and year for locale
 *
 * @param unitOrder
 */
function getOrder(unitOrder) {
  const signifiers = ["d", "m", "y"];
  const order = unitOrder.toLowerCase();
  return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));
}
/**
 * Get number of days between two dates
 *
 * @param date1
 * @param date2
 */
function getDaysDiff(date1, date2) {
  const ts1 = date1.getTime();
  const ts2 = date2.getTime();
  return (ts1 - ts2) / (1000 * 3600 * 24);
}
/**
 * Set time of the day to the end.
 *
 * @param {Date} date Date.
 * @returns {Date} Date with time set to end of day .
 */
function setEndOfDay(date) {
  date.setHours(23, 59, 59, 999);
  return date;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzX2Rpc3RfY29tcG9uZW50c19kYXRlX2pzLV8zZGVlMS5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBLHVEQUF1RCx5Q0FBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW52aWV3Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NvbXBvbmVudHMvZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuNy4wXG4gKi9cbmltcG9ydCB7IG4gYXMgbnVtYmVyU3RyaW5nRm9ybWF0dGVyIH0gZnJvbSAnLi9sb2NhbGUuanMnO1xuXG4vKipcbiAqIENoZWNrIGlmIGRhdGUgaXMgd2l0aGluIGEgbWluIGFuZCBtYXhcbiAqXG4gKiBAcGFyYW0gZGF0ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiBpblJhbmdlKGRhdGUsIG1pbiwgbWF4KSB7XG4gIGlmICghZGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGNvbnN0IGFmdGVyTWluID0gIShtaW4gaW5zdGFuY2VvZiBEYXRlKSB8fCB0aW1lID49IG1pbi5nZXRUaW1lKCk7XG4gIGNvbnN0IGJlZm9yZU1heCA9ICEobWF4IGluc3RhbmNlb2YgRGF0ZSkgfHwgdGltZSA8PSBtYXguZ2V0VGltZSgpO1xuICByZXR1cm4gYWZ0ZXJNaW4gJiYgYmVmb3JlTWF4O1xufVxuLyoqXG4gKiBFbnN1cmVzIGRhdGUgaXMgd2l0aGluIHJhbmdlLFxuICogcmV0dXJucyBtaW4gb3IgbWF4IGlmIG91dCBvZiBib3VuZHNcbiAqXG4gKiBAcGFyYW0gZGF0ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiBkYXRlRnJvbVJhbmdlKGRhdGUsIG1pbiwgbWF4KSB7XG4gIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRpbWUgPSBkYXRlLmdldFRpbWUoKTtcbiAgY29uc3QgYmVmb3JlTWluID0gbWluIGluc3RhbmNlb2YgRGF0ZSAmJiB0aW1lIDwgbWluLmdldFRpbWUoKTtcbiAgY29uc3QgYWZ0ZXJNYXggPSBtYXggaW5zdGFuY2VvZiBEYXRlICYmIHRpbWUgPiBtYXguZ2V0VGltZSgpO1xuICBpZiAoYmVmb3JlTWluKSB7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBpZiAoYWZ0ZXJNYXgpIHtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHJldHVybiBkYXRlO1xufVxuLyoqXG4gKiBQYXJzZSBhbiBpc284NjAxIHN0cmluZyAoWVlZWS1tbS1kZCkgaW50byBhIHZhbGlkIGRhdGUuXG4gKiBUT0RPOiBoYW5kbGUgdGltZSB3aGVuIHRpbWUgb2YgZGF5IFVJIGlzIGFkZGVkXG4gKlxuICogQHBhcmFtIGlzbzg2MDFcbiAqIEBwYXJhbSBpc0VuZERhdGVcbiAqL1xuZnVuY3Rpb24gZGF0ZUZyb21JU08oaXNvODYwMSwgaXNFbmREYXRlID0gZmFsc2UpIHtcbiAgaWYgKGlzbzg2MDEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGlzbzg2MDE7XG4gIH1cbiAgaWYgKCFpc284NjAxIHx8IHR5cGVvZiBpc284NjAxICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZCA9IGlzbzg2MDEuc3BsaXQoL1s6IFQtXS8pLm1hcChwYXJzZUZsb2F0KTtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRbMF0sIChkWzFdIHx8IDEpIC0gMSwgZFsyXSB8fCAxKTtcbiAgZGF0ZS5zZXRGdWxsWWVhcihkWzBdKTtcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJU08gODYwMSBkYXRlOiBcIiR7aXNvODYwMX1cImApO1xuICB9XG4gIGlmIChpc0VuZERhdGUpIHtcbiAgICByZXR1cm4gc2V0RW5kT2ZEYXkoZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGRhdGU7XG59XG4vKipcbiAqIFBhcnNlIGEgbG9jYWxpemVkIGRhdGUgc3RyaW5nIGludG8gYSB2YWxpZCBEYXRlLlxuICogcmV0dXJuIGZhbHNlIGlmIGRhdGUgaXMgaW52YWxpZCwgb3Igb3V0IG9mIHJhbmdlXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gbG9jYWxlRGF0YVxuICovXG5mdW5jdGlvbiBkYXRlRnJvbUxvY2FsaXplZFN0cmluZyh2YWx1ZSwgbG9jYWxlRGF0YSkge1xuICBpZiAoIWxvY2FsZURhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IHNlcGFyYXRvciB9ID0gbG9jYWxlRGF0YTtcbiAgY29uc3QgcGFydHMgPSBwYXJzZURhdGVTdHJpbmcodmFsdWUsIGxvY2FsZURhdGEpO1xuICBjb25zdCB7IGRheSwgbW9udGggfSA9IHBhcnRzO1xuICBjb25zdCB5ZWFyID0gcGFyc2VDYWxlbmRhclllYXIocGFydHMueWVhciwgbG9jYWxlRGF0YSk7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgZGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgY29uc3QgdmFsaWREYXkgPSBkYXkgPiAwO1xuICBjb25zdCB2YWxpZE1vbnRoID0gbW9udGggPiAtMTtcbiAgY29uc3QgdmFsaWREYXRlID0gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcbiAgY29uc3QgdmFsaWRMZW5ndGggPSB2YWx1ZS5zcGxpdChzZXBhcmF0b3IpLmZpbHRlcigoYykgPT4gYykubGVuZ3RoID4gMjtcbiAgY29uc3QgdmFsaWRZZWFyID0geWVhci50b1N0cmluZygpLmxlbmd0aCA+IDA7XG4gIGlmICh2YWxpZERheSAmJiB2YWxpZE1vbnRoICYmIHZhbGlkRGF0ZSAmJiB2YWxpZExlbmd0aCAmJiB2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsZW5kYXJZZWFyKHllYXIsIGxvY2FsZURhdGEpIHtcbiAgcmV0dXJuIHByb2Nlc3NDYWxlbmRhclllYXIoeWVhciwgbG9jYWxlRGF0YSwgXCJyZWFkXCIpO1xufVxuZnVuY3Rpb24gZm9ybWF0Q2FsZW5kYXJZZWFyKHllYXIsIGxvY2FsZURhdGEpIHtcbiAgcmV0dXJuIHByb2Nlc3NDYWxlbmRhclllYXIoeWVhciwgbG9jYWxlRGF0YSwgXCJ3cml0ZVwiKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NDYWxlbmRhclllYXIoeWVhciwgbG9jYWxlRGF0YSwgbW9kZSkge1xuICBpZiAobG9jYWxlRGF0YVtcImRlZmF1bHQtY2FsZW5kYXJcIl0gIT09IFwiYnVkZGhpc3RcIikge1xuICAgIHJldHVybiB5ZWFyO1xuICB9XG4gIGNvbnN0IEJVRERISVNUX0NBTEVOREFSX1lFQVJfT0ZGU0VUID0gNTQzO1xuICBjb25zdCB5ZWFyT2Zmc2V0ID0gQlVEREhJU1RfQ0FMRU5EQVJfWUVBUl9PRkZTRVQgKiAobW9kZSA9PT0gXCJyZWFkXCIgPyAtMSA6IDEpO1xuICByZXR1cm4geWVhciArIHllYXJPZmZzZXQ7XG59XG4vKipcbiAqIFJldHJpZXZlIGRheSwgbW9udGgsIGFuZCB5ZWFyIHN0cmluZ3MgZnJvbSBhIGxvY2FsaXplZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcGFyYW0gbG9jYWxlRGF0YVxuICovXG5mdW5jdGlvbiBkYXRlUGFydHNGcm9tTG9jYWxpemVkU3RyaW5nKHN0cmluZywgbG9jYWxlRGF0YSkge1xuICBjb25zdCB7IHNlcGFyYXRvciwgdW5pdE9yZGVyIH0gPSBsb2NhbGVEYXRhO1xuICBjb25zdCBvcmRlciA9IGdldE9yZGVyKHVuaXRPcmRlcik7XG4gIGNvbnN0IHZhbHVlcyA9IHN0cmluZy5zcGxpdChzZXBhcmF0b3IpLm1hcCgocGFydCkgPT4gbnVtYmVyU3RyaW5nRm9ybWF0dGVyLmRlbG9jYWxpemUocGFydCkpO1xuICBjb25zdCBkYXkgPSB2YWx1ZXNbb3JkZXIuaW5kZXhPZihcImRcIildO1xuICBjb25zdCBtb250aCA9IHZhbHVlc1tvcmRlci5pbmRleE9mKFwibVwiKV07XG4gIGNvbnN0IHllYXIgPSB2YWx1ZXNbb3JkZXIuaW5kZXhPZihcInlcIildO1xuICByZXR1cm4geyBkYXksIG1vbnRoLCB5ZWFyIH07XG59XG4vKipcbiAqIFJldHVybiBmaXJzdCBwb3J0aW9uIG9mIElTTyBzdHJpbmcgKFlZWVktbW0tZGQpXG4gKlxuICogQHBhcmFtIGRhdGVcbiAqL1xuZnVuY3Rpb24gZGF0ZVRvSVNPKGRhdGUpIHtcbiAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSBkYXksIG1vbnRoLCBhbmQgeWVhciBzdHJpbmdzIGZyb20gYSBJU08gc3RyaW5nIChZWVlZLW1tLWRkKVxuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBpc29EYXRlXG4gKi9cbmZ1bmN0aW9uIGRhdGVQYXJ0c0Zyb21JU08oaXNvRGF0ZSkge1xuICBjb25zdCBkYXRlUGFydHMgPSBpc29EYXRlLnNwbGl0KFwiLVwiKTtcbiAgcmV0dXJuIHsgZGF5OiBkYXRlUGFydHNbMl0sIG1vbnRoOiBkYXRlUGFydHNbMV0sIHllYXI6IGRhdGVQYXJ0c1swXSB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gZGF0ZXMgYXJlIHRoZSBzYW1lIGRheSwgbW9udGgsIHllYXJcbiAqXG4gKiBAcGFyYW0gZDFcbiAqIEBwYXJhbSBkMlxuICovXG5mdW5jdGlvbiBzYW1lRGF0ZShkMSwgZDIpIHtcbiAgcmV0dXJuIChkMSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICBkMiBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICBkMS5nZXREYXRlKCkgPT09IGQyLmdldERhdGUoKSAmJlxuICAgIGQxLmdldE1vbnRoKCkgPT09IGQyLmdldE1vbnRoKCkgJiZcbiAgICBkMS5nZXRGdWxsWWVhcigpID09PSBkMi5nZXRGdWxsWWVhcigpKTtcbn1cbi8qKlxuICogR2V0IGEgZGF0ZSBvbmUgbW9udGggaW4gdGhlIHBhc3RcbiAqXG4gKiBAcGFyYW0gZGF0ZVxuICovXG5mdW5jdGlvbiBwcmV2TW9udGgoZGF0ZSkge1xuICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgY29uc3QgbmV4dERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgbmV4dERhdGUuc2V0TW9udGgobW9udGggLSAxKTtcbiAgLy8gZGF0ZSBkb2Vzbid0IGV4aXN0IGluIG5ldyBtb250aCwgdXNlIGxhc3QgZGF5XG4gIGlmIChtb250aCA9PT0gbmV4dERhdGUuZ2V0TW9udGgoKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIG1vbnRoLCAwKTtcbiAgfVxuICByZXR1cm4gbmV4dERhdGU7XG59XG4vKipcbiAqIEdldCBhIGRhdGUgb25lIG1vbnRoIGluIHRoZSBmdXR1cmVcbiAqXG4gKiBAcGFyYW0gZGF0ZVxuICovXG5mdW5jdGlvbiBuZXh0TW9udGgoZGF0ZSkge1xuICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgY29uc3QgbmV4dERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgbmV4dERhdGUuc2V0TW9udGgobW9udGggKyAxKTtcbiAgLy8gZGF0ZSBkb2Vzbid0IGV4aXN0IGluIG5ldyBtb250aCwgdXNlIGxhc3QgZGF5XG4gIGlmICgobW9udGggKyAyKSAlIDcgPT09IG5leHREYXRlLmdldE1vbnRoKCkgJSA3KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGggKyAyLCAwKTtcbiAgfVxuICByZXR1cm4gbmV4dERhdGU7XG59XG4vKipcbiAqIFBhcnNlIG51bWVyaWMgdW5pdHMgZm9yIGRheSwgbW9udGgsIGFuZCB5ZWFyIGZyb20gYSBsb2NhbGl6ZWQgc3RyaW5nXG4gKiBtb250aCBzdGFydHMgYXQgMCAoY2FuIHBhc3MgdG8gZGF0ZSBjb25zdHJ1Y3RvcilcbiAqIGNhbiByZXR1cm4gdmFsdWVzIGFzIG51bWJlciBvciBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcGFyYW0gbG9jYWxlRGF0YVxuICovXG5mdW5jdGlvbiBwYXJzZURhdGVTdHJpbmcoc3RyaW5nLCBsb2NhbGVEYXRhKSB7XG4gIGNvbnN0IHsgZGF5LCBtb250aCwgeWVhciB9ID0gZGF0ZVBhcnRzRnJvbUxvY2FsaXplZFN0cmluZyhzdHJpbmcsIGxvY2FsZURhdGEpO1xuICByZXR1cm4ge1xuICAgIGRheTogcGFyc2VJbnQoZGF5KSxcbiAgICBtb250aDogcGFyc2VJbnQobW9udGgpIC0gMSxcbiAgICB5ZWFyOiBwYXJzZUludCh5ZWFyKSxcbiAgfTtcbn1cbi8qKlxuICogQmFzZWQgb24gdGhlIHVuaXRPcmRlciBzdHJpbmcsIGZpbmQgb3JkZXIgb2YgbW9udGgsIGRheSwgYW5kIHllYXIgZm9yIGxvY2FsZVxuICpcbiAqIEBwYXJhbSB1bml0T3JkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0T3JkZXIodW5pdE9yZGVyKSB7XG4gIGNvbnN0IHNpZ25pZmllcnMgPSBbXCJkXCIsIFwibVwiLCBcInlcIl07XG4gIGNvbnN0IG9yZGVyID0gdW5pdE9yZGVyLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBzaWduaWZpZXJzLnNvcnQoKGEsIGIpID0+IG9yZGVyLmluZGV4T2YoYSkgLSBvcmRlci5pbmRleE9mKGIpKTtcbn1cbi8qKlxuICogR2V0IG51bWJlciBvZiBkYXlzIGJldHdlZW4gdHdvIGRhdGVzXG4gKlxuICogQHBhcmFtIGRhdGUxXG4gKiBAcGFyYW0gZGF0ZTJcbiAqL1xuZnVuY3Rpb24gZ2V0RGF5c0RpZmYoZGF0ZTEsIGRhdGUyKSB7XG4gIGNvbnN0IHRzMSA9IGRhdGUxLmdldFRpbWUoKTtcbiAgY29uc3QgdHMyID0gZGF0ZTIuZ2V0VGltZSgpO1xuICByZXR1cm4gKHRzMSAtIHRzMikgLyAoMTAwMCAqIDM2MDAgKiAyNCk7XG59XG4vKipcbiAqIFNldCB0aW1lIG9mIHRoZSBkYXkgdG8gdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgRGF0ZS5cbiAqIEByZXR1cm5zIHtEYXRlfSBEYXRlIHdpdGggdGltZSBzZXQgdG8gZW5kIG9mIGRheSAuXG4gKi9cbmZ1bmN0aW9uIHNldEVuZE9mRGF5KGRhdGUpIHtcbiAgZGF0ZS5zZXRIb3VycygyMywgNTksIDU5LCA5OTkpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuZXhwb3J0IHsgZGF0ZVBhcnRzRnJvbUxvY2FsaXplZFN0cmluZyBhcyBhLCBkYXRlRnJvbUxvY2FsaXplZFN0cmluZyBhcyBiLCBkYXRlVG9JU08gYXMgYywgZGF0ZVBhcnRzRnJvbUlTTyBhcyBkLCBkYXRlRnJvbUlTTyBhcyBlLCBkYXRlRnJvbVJhbmdlIGFzIGYsIGdldERheXNEaWZmIGFzIGcsIHNhbWVEYXRlIGFzIGgsIGluUmFuZ2UgYXMgaSwgZ2V0T3JkZXIgYXMgaiwgZm9ybWF0Q2FsZW5kYXJZZWFyIGFzIGssIHBhcnNlQ2FsZW5kYXJZZWFyIGFzIGwsIG5leHRNb250aCBhcyBuLCBwcmV2TW9udGggYXMgcCwgc2V0RW5kT2ZEYXkgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9